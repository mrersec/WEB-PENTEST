- XSS (Cross-Site Scripting) açıklarını tamamen kapatmak için genellikle sadece bir teknik yeterli olmayabilir. Her bir yöntem farklı senaryolarda etkilidir ve genellikle birden fazla teknik kullanılması önerilir.

      #### 1. Girdi Doğrulama ve Temizleme

- Kullanıcıdan gelen verileri doğrulamak ve temizlemek XSS risklerini azaltabilir. Örneğin, sadece belirli karakterlere izin verebilirsiniz.

// Örnek: Kullanıcının yalnızca harf ve rakam girmesine izin verme
function sanitizeInput(input) {
    return input.replace(/[^a-zA-Z0-9]/g, '');
}

let userInput = "<script>alert('XSS');</script>";
let safeInput = sanitizeInput(userInput);
console.log(safeInput); // Çıktı: "alertXSS"


      #### 2. HTML Özelliklerinde Kullanım

- HTML özniteliklerinde dinamik veri kullanırken, textContent veya setAttribute gibi güvenli yöntemler kullanmak iyi bir yaklaşımdır.

// Kullanıcı verisini HTML öğesine güvenli bir şekilde ekleme
let userInput = "<script>alert('XSS');</script>";
let div = document.createElement('div');
div.textContent = userInput; // Metin olarak eklenir, XSS riskini azaltır
document.body.appendChild(div);


      #### 3. HTML Özniteliklerinde Güvenlik

- HTML özniteliklerinde dinamik veri kullanırken, setAttribute gibi yöntemlerle veriyi eklemek daha güvenlidir.

// Dinamik veri eklerken `setAttribute` kullanma
let userInput = "http://example.com?param=<script>alert('XSS');</script>";
let link = document.createElement('a');
link.setAttribute('href', userInput); // Güvenli bir şekilde özniteliğe ekler
document.body.appendChild(link);


      #### 4. JavaScript Şablonları

- Şablon motorları veya innerHTML gibi dinamik HTML oluşturma yöntemlerinden kaçının. Bunun yerine, güvenli yöntemler kullanın.

// Dinamik HTML oluşturma sırasında dikkatli olma
let userInput = "<script>alert('XSS');</script>";
let div = document.createElement('div');
div.innerText = userInput; // innerText veya textContent kullanarak XSS riskini azaltma
document.body.appendChild(div);


      #### 5. Content Security Policy (CSP)

- Tarayıcı bazında XSS risklerini azaltmak için CSP kullanabilirsiniz.

<!-- CSP ile güvenlik ekleme -->
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self';">


      #### 6. Escape Etme

- HTML içeriği dinamik olarak oluşturulurken, kullanıcı verilerini uygun şekilde kaçırmak önemlidir.

// HTML karakterlerini kaçırma
function escapeHtml(text) {
    const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#039;'
    };
    return text.replace(/[&<>"']/g, function(m) { return map[m]; });
}

let userInput = "<script>alert('XSS');</script>";
let safeInput = escapeHtml(userInput);
let div = document.createElement('div');
div.innerHTML = safeInput; // Kaçırılmış HTML içeriği eklenir
document.body.appendChild(div);


      #### 7. DOMPurify Kullanımı

- DOMPurify, güvenli bir şekilde HTML içeriği temizlemek için kullanılan bir kütüphanedir. Kullanıcıdan gelen verileri temizlemek için kullanabilirsiniz.

// DOMPurify kullanarak XSS risklerini azaltma
// DOMPurify'yi npm veya CDN ile eklemeyi unutmayın
// <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.3.6/purify.min.js"></script>

let userInput = "<script>alert('XSS');</script>";
let cleanInput = DOMPurify.sanitize(userInput);
let div = document.createElement('div');
div.innerHTML = cleanInput;
document.body.appendChild(div);

      #### 8. iframe Kullanımı

- Kullanıcıdan gelen verileri tamamen izole bir ortamda görüntülemek için iframe kullanabilirsiniz. Bu, XSS risklerini sınırlayabilir.

// Kullanıcı verilerini güvenli bir şekilde `iframe` içinde gösterme
let userInput = "<script>alert('XSS');</script>";
let iframe = document.createElement('iframe');
iframe.srcdoc = `<html><body>${userInput}</body></html>`;
document.body.appendChild(iframe);


      #### 9. HTTP Header Güvenliği

- HTTP başlıkları, XSS risklerini azaltmak için sunucu tarafında güvenlik ekleyebilir. Örneğin, X-XSS-Protection ve X-Content-Type-Options başlıklarını kullanabilirsiniz.

// Sunucu tarafında HTTP başlıklarını ekleme
X-XSS-Protection: 1; mode=block
X-Content-Type-Options: nosniff


      #### 10. JavaScript Kütüphaneleri ve Framework'ler

- Modern JavaScript framework'leri ve kütüphaneleri (örneğin, React, Angular, Vue) genellikle XSS'den korunmak için güvenli yöntemler ve API'ler sunar. Bu framework'lerin HTML yerleştirme yöntemlerini kullanmak daha güvenlidir.

// React örneği
import React from 'react';

function App() {
    const userInput = "<script>alert('XSS');</script>";
    return (
        <div>
            {/* React, içeriği otomatik olarak kaçırır */}
            <div>{userInput}</div>
        </div>
    );
}


      #### 11. eval() ve Function Kullanımından Kaçınma

- JavaScript kodlarını dinamik olarak çalıştırmak için eval() veya Function kullanmaktan kaçının, çünkü bu XSS risklerini artırabilir.

// Kötü örnek: `eval` kullanımı
let userInput = "alert('XSS')";
eval(userInput); // Tehlikeli! Kullanımdan kaçının

// Güvenli örnek: `eval` yerine güvenli API kullanma
function safeFunction(userInput) {
    // Kullanıcı girişini işleme
}


      #### 12. JavaScript Kodları ile document.createElement ve appendChild Kullanımı

- Dinamik olarak HTML öğeleri oluştururken, createElement ve appendChild gibi yöntemler kullanarak kullanıcı verilerini güvenli bir şekilde ekleyebilirsiniz.

// Güvenli yöntemle HTML öğesi oluşturma
let userInput = "<script>alert('XSS');</script>";
let div = document.createElement('div');
div.textContent = userInput; // `textContent` kullanarak XSS riskini azaltma

- XSS açıklarını önlemek için kullanılan yöntemler genel olarak bu listeyle sınırlı olsa da, çeşitli senaryolara göre başka yöntemler de uygulanabilir. İşte bu yöntemlerin kısa açıklamaları ve kod örnekleri:

     
      #### 13. Güvenli document.write Kullanımı

- Genellikle document.write kullanımı önerilmez, ancak doğru şekilde kullanıldığında riski azaltabilir.

// Güvenli bir şekilde `document.write` kullanma
let userInput = "<p>Safe Content</p>";
document.write(userInput); // Dikkatli kullanılmalıdır


      #### 14. encodeURIComponent Kullanımı

- Parametreleri URL'de güvenli bir şekilde işlemek için encodeURIComponent kullanabilirsiniz.

// URL parametrelerini güvenli bir şekilde encode etme
let userInput = "<script>alert('XSS');</script>";
let encodedInput = encodeURIComponent(userInput);
let url = `http://example.com?param=${encodedInput}`;


      #### 15. Sanitization Kütüphaneleri

- XSS'den koruma sağlayan başka kütüphaneler de vardır. xss ve sanitize-html gibi popüler kütüphaneler kullanılabilir.

// `xss` kütüphanesi kullanarak HTML'i temizleme
// npm install xss veya CDN ile yükleyin
// <script src="https://cdn.jsdelivr.net/npm/xss@1.0.8/dist/xss.min.js"></script>

let userInput = "<script>alert('XSS');</script>";
let cleanInput = xss(userInput);
let div = document.createElement('div');
div.innerHTML = cleanInput;
document.body.appendChild(div);


      #### 16. sandbox Özelliği ile <iframe> Kullanımı

- iframe'i sandbox modunda kullanarak içeriği izole edebilirsiniz.

<iframe src="about:blank" sandbox="allow-same-origin allow-scripts"></iframe>


      #### 17. Güvenli JavaScript API'leri Kullanımı

- Güvenli JavaScript API'lerini kullanmak XSS risklerini azaltabilir. Örneğin, DOM API'leri yerine template literals kullanmak.

// Güvenli API kullanımı
let userInput = "<script>alert('XSS');</script>";
let safeContent = document.createElement('div');
safeContent.textContent = userInput; // XSS riskini azaltır
document.body.appendChild(safeContent);


      #### 18. setTimeout ve setInterval'da Function Kullanımı

- Dinamizmi setTimeout ve setInterval ile işlemek için Function yerine güvenli yöntemler kullanın.

// Güvenli `setTimeout` kullanımı
let userInput = "alert('XSS')";
setTimeout(() => {
    // Kullanıcı verisini çalıştırmak yerine güvenli kod çalıştırın
    console.log("Time's up!");
}, 1000);


      #### 19. Form Veri Doğrulama

- Form verilerini doğrularken, istemci ve sunucu tarafında her zaman doğrulama yapmalısınız.

// Basit form doğrulama
document.querySelector('form').addEventListener('submit', function(event) {
    let userInput = document.querySelector('input[name="data"]').value;
    if (/<script/i.test(userInput)) {
        event.preventDefault(); // Formun gönderilmesini engelleme
        alert('Invalid input detected!');
    }
});


- XSS açıklarını önlemek için daha önce bahsetmediğimiz bazı ek yöntemler ve teknikler aşağıda belirtilmiştir. Her biri farklı senaryolar için geçerli olabilir ve birlikte kullanıldığında daha etkili bir güvenlik sağlar.
     
      #### 20. innerHTML Kullanımında Güvenlik

- innerHTML kullanırken dikkatli olunmalı. Doğrudan kullanıcı verisi eklemek yerine, textContent veya innerText kullanmak daha güvenlidir.

// Güvenli bir şekilde kullanıcı verisi ekleme
let userInput = "<script>alert('XSS');</script>";
let div = document.createElement('div');
div.textContent = userInput; // XSS riskini azaltır
document.body.appendChild(div);

      #### 21. URL.createObjectURL Kullanımı

- Dış kaynaklardan güvenli URL'ler oluşturmak için URL.createObjectURL kullanabilirsiniz. Bu yöntem genellikle dosya yüklemeleri için kullanılır.

// Güvenli URL oluşturma
let blob = new Blob(["<script>alert('XSS');</script>"], { type: 'text/html' });
let url = URL.createObjectURL(blob);
let iframe = document.createElement('iframe');
iframe.src = url;
document.body.appendChild(iframe);


      #### 22. DOMTokenList ile Sınıf Eklemek

- classList.add ile sınıf eklerken, doğrudan kullanıcı verisini kullanmak yerine sınıfları güvenli bir şekilde yönetebilirsiniz.

// Güvenli sınıf ekleme
let userInput = "danger";
let element = document.createElement('div');
element.classList.add(userInput); // Sınıf eklerken dikkatli olunmalı
document.body.appendChild(element);


      #### 23. JSON.stringify ve JSON.parse Kullanımı

- Kullanıcıdan gelen JSON verilerini işlemek için JSON.stringify ve JSON.parse kullanarak veriyi güvenli bir şekilde işleyebilirsiniz.

// JSON veri işleme
let userInput = '{"key": "<script>alert(\'XSS\');</script>"}';
try {
    let data = JSON.parse(userInput);
    console.log(data.key); // JSON verilerini işleme
} catch (e) {
    console.error('Invalid JSON');
}


      #### 24. MutationObserver ile Güvenli DOM Değişiklikleri

- MutationObserver kullanarak DOM'da yapılan değişiklikleri izleyebilir ve güvenliğini kontrol edebilirsiniz.

// MutationObserver ile DOM değişikliklerini izleme
let observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
        if (mutation.type === 'childList') {
            mutation.addedNodes.forEach((node) => {
                if (node.nodeType === Node.ELEMENT_NODE) {
                    console.log('New node added:', node);
                }
            });
        }
    });
});

observer.observe(document.body, { childList: true, subtree: true });

      #### 25. Object.freeze ve Object.seal Kullanımı

- JavaScript nesnelerini dondurmak veya mühürlemek, değişiklikleri kontrol etmenize yardımcı olabilir.

// Nesneleri dondurmak
let userInput = { name: "<script>alert('XSS');</script>" };
Object.freeze(userInput);
userInput.name = "New Value"; // Bu işlem başarısız olur
console.log(userInput.name); // "<script>alert('XSS');</script>"


      #### 26. window.postMessage Kullanımı

- Çerçeveler arasında güvenli veri iletimi için postMessage kullanabilirsiniz.

// Güvenli veri iletimi
let targetWindow = document.getElementById('iframe').contentWindow;
targetWindow.postMessage({ data: "<script>alert('XSS');</script>" }, '*');

// Alıcı pencerede mesajı işleme
window.addEventListener('message', (event) => {
    console.log('Message received:', event.data);
});


      #### 27. Sanitasyon ve Validasyon Kütüphanelerini Güncel Tutma

- Sanitasyon ve validasyon kütüphanelerini güncel tutmak, bilinen güvenlik açıklarına karşı koruma sağlar.

// npm veya CDN ile kütüphaneleri güncel tutma
// Örneğin, DOMPurify ve xss kütüphanelerinin güncel sürümlerini kullanma

!--> Her zaman uygulamanızın güvenliğini sağlamak için birden fazla katmanı kullanmak en iyisidir.
